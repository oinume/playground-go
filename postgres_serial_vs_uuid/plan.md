# serial or uuid type in PostgreSQL

## これはなに？

PostgreSQLにおいて、PKとなるidの型がserialとuuidでどのぐらいパフォーマンスに差があるのかを検証する。

### 検証ポイント

1. INSERT時のパフォーマンス
2. 参照の局所性 (詳細はこのファイルの末尾に記載)

### 検証方法

- docker-compose でPostgreSQL v18をセットアップする
- serial型は`bigserial`型を使う
- UUID v7を使う
- INSERT時のパフォーマンスを検証するため、シンプルなテーブルを作成しGoのテストコードを書く
- 参照の局所性を検証するため、100万レコードを保持するテーブルを作成しておき、メモリ(shared_buffer)を8MBほどにして検証するGoのテストコードを書く

## 参照の局所性

Quoraに以下のような質問があった。

質問：データベースでユニークキーにUUIDを使うメリットは何ですか？連番やタイムスタンプまたは複合などではいけないのでしょうか？どうも視認性が悪く使いにくく感じますし連番でも衝突しない気もします

回答：

結論から言うと、プライマリキーには原則としてデータベース側で発行される自動インクリメントの連番を使っておくのが間違いない、と覚えておいてください。
UUIDを使いたくなる理由は、究極的には以下の2点に集約されます。

大規模な分散システムを設計していてSPOFが許されない
独立したサブシステムごとにグローバルで衝突しないIDを発行したい
IDを乱数化してユーザーから類推しにくくする
1を設計している人が以下に述べるUUIDの弱点を理解しておらず、色々と提案されているUUIDの代替アルゴリズムを知らないとすれば、そもそも分散システムを設計するための基本的なスキルが不足していると言わざるをえません。

また2についても、プライマリキーをUUIDにする莫大なコストには全く見合わないので、プライマリキーは連番のままにしておき、public_idという別カラムを用意してそこに乱数ベースのデータを入れてユニーク制約をかけておきます。

そして、ユーザーに見えるUIに出てくるIDは常に乱数ベースのpublic_idを使い、内部での処理にはすべて連番のIDを使います。こういうケースは多いので、Ruby on Railsなどのフレームワークではこうした「代理ID」の扱いが簡単にできるようになっています。

さて、ではなぜUUID（および乱数ベースのID）が駄目なのか。

Naoki Fujitaさんの回答 で触れられているこの記事、とても良いです。
https://techblog.raccoon.ne.jp/archives/1627262796.html


つまり、簡単にいうと

乱数は「参照の局所性」（Locality of Reference）というコンピューターサイエンス最強の武器を殺してしまう

という問題があるのです。

参照の局所性というのは、平たく言うと「キャッシュヒット率」のことです。1度使われたデータはまたすぐ使われる可能性が高いのでCPUの近くに置いておく。1度使われたデータの近くにあるデータ（直近100件の明細などの塊）もすぐ使われる可能性が高いのでディスクからメモリに読み込んで保持しておく。

現実世界のアプリケーションでは、こうした時間的・空間的なデータの「偏り」があるために、キャッシュがとてもよく効きます。コンピューター・サイエンスという学問領域ではデータ構造やアルゴリズムについて研究しますが、この「参照の局所性」がそのコアにあるといっても過言ではありません。（たとえばハフマン符号などのデータ圧縮のアルゴリズムも、データの「偏り」を利用します。完全にランダムなデータは圧縮しても縮みません）

今回の例でいうと、プライマリキーで連番をふっていくと、数字が大きい方、つまり最近作られたデータに対するアクセスがもっとも多くなります。
